;; Lite client for Testnet, to be deployed on Fastnet
#include "imports/stdlib.fc";

const op::new_key_block = 0x11a78ffe;
const op::check_block = 0x8eaa9d76;
const op::ok = 0xff8ff4e1;
const op::correct = 0xce02b807;
const error::unknown_opcode = 0xffff;
const error::unknown_param_type = 0xf100;
const error::not_a_key_block = 0xf101;
const error::block_does_not_correspond_to_current_epoch = 0xf102;

(slice, int) parse_exotic(cell x) asm "XCTOS";
int hash_at_level(cell x, int i) asm "CHASHIX";
int slice_hash_2(builder b1, builder b2, int n) asm "HASHEXT_SHA256";
int check_signature_for_slice(slice message, slice signature, int public_key) asm "CHKSIGNS";

(cell, cell, cell, int, int) load_data() inline_ref {
    slice ds = get_data().begin_parse();
    cell prev_validator_set = ds~load_dict();
    cell cur_validator_set = ds~load_dict();
    cell next_validator_set = ds~load_dict();
    int utime_since = ds~load_uint(32);
    int utime_until = ds~load_uint(32);
    return (
        prev_validator_set,
        cur_validator_set,
        next_validator_set,
        utime_since,
        utime_until
    );
}

() save_data(cell prev_validator_set, cell cur_validator_set, cell next_validator_set, int utime_since, int utime_until) impure {
    set_data(
        begin_cell()
            .store_dict(prev_validator_set)
            .store_dict(cur_validator_set)
            .store_dict(next_validator_set)
            .store_uint(utime_since, 32)
            .store_uint(utime_until, 32)
            .end_cell()
    );
}

(int, int, int, int, int, int) parse_block_id(slice block_id_cs) inline {
    int block_id_kind = block_id_cs~load_int(32);
    int block_id_workchain = block_id_cs~load_int(32);
    int block_id_shard = block_id_cs~load_int(64);
    int block_id_seqno = block_id_cs~load_int(32);
    int block_id_root_hash = block_id_cs~load_uint(256);
    int block_id_file_hash = block_id_cs~load_uint(256);
    return (block_id_kind, block_id_workchain, block_id_shard, block_id_seqno, block_id_root_hash, block_id_file_hash);
}

(slice, int) verify_block_header(slice block_header_cs) impure inline {
    int block_header_kind = block_header_cs~load_int(32);
    slice block_header_id_cs = block_header_cs~load_ref().begin_parse();
    int block_header_mode = block_header_cs~load_uint(32);
    cell header_proof = block_header_cs~load_ref();  

    (int block_header_id_kind, int block_header_id_workchain, int block_header_id_shard, int block_header_id_seqno, int block_header_id_root_hash, int block_header_id_file_hash) = parse_block_id(block_header_id_cs);

    ;; verifying the block header
    ;; we should check that seqno in deserialized block matches to block seqno we know (in wrappers)
    ;;then compute hash_1 of the only Merkle Proof reference and compare it to block hash we know (in wrappers and contract) -> assert h_proof.refs[0].get_hash(0) == block_id.root_hash
    (slice header_proof_slice, int is_exotic) = parse_exotic(header_proof);
    throw_unless(0xf001, is_exotic == -1);
    throw_unless(0xf002, slice_bits(header_proof_slice) == 280);
    throw_unless(0xf003, header_proof_slice~load_uint(8) == 3);

    int root_hash = hash_at_level(header_proof_slice~load_ref(), 0);
    throw_unless(0xf004, root_hash == header_proof_slice~load_uint(256));
    throw_unless(0xf005, root_hash == block_header_id_root_hash);
    ~strdump("header root hash is ok");
    return (block_header_id_cs, root_hash);
}

(slice)  verify_block_data(slice block_data_cs, slice block_header_id_cs) impure inline {
    int block_data_kind = block_data_cs~load_int(32);
    slice block_data_id_cs = block_data_cs~load_ref().begin_parse();
    cell block_data_c = block_data_cs~load_ref();

    (int block_data_id_kind, int block_data_id_workchain, int block_data_id_shard, int block_data_id_seqno, int block_data_id_root_hash, int block_data_id_file_hash) = parse_block_id(block_data_id_cs);
    
    (int block_header_id_kind, int block_header_id_workchain, int block_header_id_shard, int block_header_id_seqno, int block_header_id_root_hash, int block_header_id_file_hash) = parse_block_id(block_header_id_cs);
    throw_unless(0xf007, block_data_id_workchain == block_header_id_workchain);
    throw_unless(0xf009, block_data_id_seqno == block_header_id_seqno);
    throw_unless(0xf010, block_data_id_root_hash == block_header_id_root_hash);

    int block_data_root_hash = hash_at_level(block_data_c, 0);
    throw_unless(0xf011, block_data_root_hash == block_data_id_root_hash);
    ;; todo: check the hash with the first cell
    ~strdump("data root hash is ok");
    return (block_data_c.begin_parse());
}

(int) load_block_info(slice info) impure inline {
    int info_magic = info~load_uint(32);
    throw_unless(0xf013, info_magic == 0x9bc7a987);
    ~strdump("info magic is ok");  
    
    ;; int version = info~load_uint(32);
    ;; int not_master = info~load_uint(1);
    ;; int after_merge = info~load_uint(1);
    ;; int before_split = info~load_uint(1);
    ;; int after_split = info~load_uint(1);
    ;; int want_split = info~load_uint(1);
    ;; int want_merge = info~load_uint(1);
    ;; int key_block = info~load_uint(1);
    ;; int vert_seqno_incr = info~load_uint(1);
    ;; int flags = info~load_uint(8);
    ;; if (flags > 1) {
    ;;     throw(0xf018);
    ;; }
    ;; int seq_no = info~load_uint(32);
    ;; ~dump(seq_no);
    ;; int vert_seq_no = info~load_uint(32);
    ;; if (vert_seqno_incr > vert_seq_no) {
    ;;     throw(0xf019);
    ;; }
    ;; int prev_seq_no = seq_no - 1;
    ;; int shard_ident = info~load_uint(2);
    ;; if (shard_ident != 0) {
    ;;     throw(0xf020);
    ;; }
    ;; int shard_pfx_bits = info~load_uint(6);
    ;; int shard_workchain = info~load_int(32);
    ;; int shard_prefix = info~load_uint(64);
    
    info~load_uint(32 + 8 + 8 + 32 + 32);
    info~load_uint(2 + 6 + 32 + 64);

    int gen_utime = info~load_uint(32);
    
    return (gen_utime);
}

(slice, int) load_block_data(slice block_data_cs) impure inline {
    int data_magic = block_data_cs~load_uint(32);
    throw_unless(0xf012, data_magic == 0x11ef55aa);
    ~strdump("data magic is ok");

    int global_id = block_data_cs~load_int(32);
    slice info = block_data_cs~load_ref().begin_parse();
    int gen_utime = load_block_info(info);
    
    slice value_flow = block_data_cs~load_ref().begin_parse();
    slice state_update = block_data_cs~load_ref().begin_parse();

    return (block_data_cs, gen_utime);
}

(cell, cell, cell, int) load_config_params(slice block_data_cs) impure inline {
    throw_unless(error::not_a_key_block, slice_refs_empty?(block_data_cs) == 0);

    slice extra = block_data_cs~load_ref().begin_parse();
    extra~load_uint(32);
    extra~load_ref();
    extra~load_ref();
    extra~load_ref();
    extra~load_uint(256);   
    extra~load_uint(256);

    slice mc_block_extra = extra~load_ref().begin_parse();
    mc_block_extra~load_uint(16);
    int is_key_block = mc_block_extra~load_uint(1);
    
    mc_block_extra~load_ref();
    mc_block_extra~load_ref();
    mc_block_extra~load_ref();
    if (is_key_block) {
        cell config_params = mc_block_extra~load_dict();
        (slice config_param_32, int success) = config_params.udict_get?(32, 32);
        throw_unless(0xf014, success);
        cell config_param_32_cs = config_param_32~load_ref();
        (slice config_param_34, int success) = config_params.udict_get?(32, 34);
        throw_unless(0xf014, success);
        cell config_param_34_cs = config_param_34~load_ref();
        (slice config_param_36, int success) = config_params.udict_get?(32, 36);
        cell config_param_36_cs = begin_cell().end_cell();
        if (success) {
            config_param_36_cs = config_param_36~load_ref();
        }
        return (config_param_32_cs, config_param_34_cs, config_param_36_cs, is_key_block);
    }
    ;; mc_block_extra~load_uint(75);
    ;; int config_address = mc_block_extra~load_uint(256);
    ;; not a key block
    return (begin_cell().end_cell(), begin_cell().end_cell(), begin_cell().end_cell(), 0);
}

(cell, int, int) load_validator_set(slice config_param) impure inline {
    int param_type = config_param~load_uint(8);
    int utime_since = config_param~load_uint(32);
    int utime_until = config_param~load_uint(32);
    int total = config_param~load_uint(16);
    int main = config_param~load_uint(16);
    throw_unless(0xf015, total >= main);
    throw_unless(0xf015, main >= 1);

    cell validator_set = begin_cell().end_cell();
    if (param_type == 0x11) {
        validator_set = config_param~load_dict();
        return (validator_set, utime_since, utime_until);
    }
    if (param_type == 0x12) {
        config_param~load_uint(64);
        validator_set = config_param~load_dict();
        return (validator_set, utime_since, utime_until);
    }
    throw(error::unknown_param_type);
    return (validator_set, utime_since, utime_until);
}

(int, int, int) load_validator(slice validator) impure inline {
    int validator_type = validator~load_uint(8);
    throw_unless(0xf016, (validator_type == 0x53) | (validator_type == 0x73));
    throw_unless(0xf016, validator~load_uint(32) == 0x8e81278a);
    int pubkey = validator~load_uint(256);
    int weight = validator~load_uint(64);
    ;; if (validator_type == 0x73) {
    ;;     int adnl_addr = validator~load_uint(256);
    ;; }
    return (validator_type, pubkey, weight);
}

(int) sum_validator_weights(cell validator_set) impure inline {
    int sum = 0;
    (int key, slice value, int success) = validator_set.udict_get_min?(16);
    while (success) {
        (_, int pubkey, int weight) = load_validator(value);
        sum += weight;
        (key, value, success) = validator_set.udict_get_next?(16, key);
    }
    return (sum);
}

(int) get_validator_node_id(int pubkey) impure inline {
    int node_id_prefix = 0xc6b41348;
    int node_id = slice_hash_2(begin_cell().store_uint(node_id_prefix, 32).store_uint(pubkey, 256), begin_cell(), 2);
    return (node_id);
}

() verify_signatures(cell validator_set, cell signatures, slice message) impure inline {
    int total_weight = 0;
    int sum_total_weight = sum_validator_weights(validator_set);
    (int key, slice value, int success) = validator_set.udict_get_min?(16);
    
    while (success) {
        (_, int pubkey, int weight) = load_validator(value);
        int node_id = get_validator_node_id(pubkey);
        (slice signature, int exists) = signatures.udict_get?(256, node_id);
        if (exists) {
            slice signature_cs = signature~load_ref().begin_parse();
            int is_valid = check_signature_for_slice(message, signature_cs, pubkey);
            if (is_valid) {
                total_weight += weight;
            }
        }
        (key, value, success) = validator_set.udict_get_next?(16, key);
    }
    throw_unless(0xf017, total_weight > 0);
    throw_unless(0xf018, total_weight > sum_total_weight * 2 / 3);
    ~strdump("block is verified");
    return ();
}

() update_current_epoch(cell config_param_32_cs, cell config_param_34_cs, cell config_param_36_cs, int gen_utime) impure {
    (cell prev_validator_set, cell cur_validator_set, cell next_validator_set, int utime_since, int utime_until) = load_data();
    if (slice_data_empty?(config_param_36_cs.begin_parse())) {
        ;; This is the first key block in a new epoch, validation is done by cur_validator_set and validator set is updated
        (cell new_prev_validator_set, _, _) = load_validator_set(config_param_32_cs.begin_parse());
        (cell new_cur_validator_set, int new_utime_since, int new_utime_until) = load_validator_set(config_param_34_cs.begin_parse());
        throw_unless(0xf018, equal_slices_bits(new_cur_validator_set.begin_parse(), next_validator_set.begin_parse()));
        throw_unless(0xf019, equal_slices_bits(new_prev_validator_set.begin_parse(), cur_validator_set.begin_parse()));
        throw_unless(0xf020, (new_utime_since <= gen_utime) & (new_utime_until > gen_utime));
        save_data(new_prev_validator_set, new_cur_validator_set, begin_cell().end_cell(), new_utime_since, new_utime_until);
    } else {
        ;; This is a transitioning key block, validation is done by cur_validator_set and next validator set is updated
        (cell new_next_validator_set, _, _) = load_validator_set(config_param_36_cs.begin_parse());
        (cell new_cur_validator_set, _, _) = load_validator_set(config_param_34_cs.begin_parse());
        throw_unless(0xf021, equal_slices_bits(new_cur_validator_set.begin_parse(), cur_validator_set.begin_parse()));
        throw_unless(error::block_does_not_correspond_to_current_epoch, (utime_since < gen_utime) & (utime_until >= gen_utime));
        save_data(prev_validator_set, cur_validator_set, new_next_validator_set, utime_since, utime_until);
    }
    ~strdump("current epoch is updated");
}

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) {
        return ();
    }
    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);

    if (flags & 1) {        
        return ();
    }
    slice sender_address = cs~load_msg_addr();

    int op = in_msg_body~load_uint(32);

    (cell prev_validator_set, cell cur_validator_set, cell next_validator_set, int utime_since, int utime_until) = load_data();

    ;; ~dump(slice_data_empty?(first_ref_slice));
    ;; ~dump(slice_refs_empty?(first_ref_slice));
    ;; ~dump(slice_bits(first_ref_slice));
    ;; ~dump(slice_refs(first_ref_slice));

    if (op == op::new_key_block) {
        int query_id = in_msg_body~load_uint(64);
        cell block = in_msg_body~load_ref();
        cell signatures = in_msg_body~load_dict();

        slice block_cs = block.begin_parse();
        slice block_header_cs = block_cs~load_ref().begin_parse();
        slice block_data_cs = block_cs~load_ref().begin_parse();

        (slice block_header_id_cs, int root_hash) = verify_block_header(block_header_cs);

        slice block_data = verify_block_data(block_data_cs, block_header_id_cs);

        (block_data, int gen_utime) = load_block_data(block_data);

        (cell config_param_32_cs, cell config_param_34_cs, cell config_param_36_cs, int is_key_block) = load_config_params(block_data);
        throw_unless(error::not_a_key_block, is_key_block);

        (int block_header_id_kind, int block_header_id_workchain, int block_header_id_shard, int block_header_id_seqno, int block_header_id_root_hash, int block_header_id_file_hash) = parse_block_id(block_header_id_cs);
        slice message = begin_cell().store_uint(0x706e0bc5, 32).store_uint(root_hash, 256).store_uint(block_header_id_file_hash, 256).end_cell().begin_parse();

        verify_signatures(cur_validator_set, signatures, message);
        
        update_current_epoch(config_param_32_cs, config_param_34_cs, config_param_36_cs, gen_utime);

        var ok_msg_body = begin_cell()
                        .store_uint(op::ok, 32)
                        .store_uint(query_id, 64)
                        .store_uint(root_hash, 256)
                        .end_cell();
        var msg = begin_cell()
                .store_uint(0x18, 6)
                .store_slice(sender_address)
                .store_coins(0)
                .store_uint(1, 1 + 4 + 4 + 64 + 32 + 1 + 1)
                .store_ref(ok_msg_body);
        send_raw_message(msg.end_cell(), 64);

        return ();
    }

    if (op == op::check_block) {
        int query_id = in_msg_body~load_uint(64);
        cell block = in_msg_body~load_ref();
        cell signatures = in_msg_body~load_ref();

        slice block_cs = block.begin_parse();
        slice block_header_cs = block_cs~load_ref().begin_parse();
        slice block_data_cs = block_cs~load_ref().begin_parse();

        (slice block_header_id_cs, int root_hash) = verify_block_header(block_header_cs);

        slice block_data = verify_block_data(block_data_cs, block_header_id_cs);

        (block_data, int gen_utime) = load_block_data(block_data);

        throw_unless(0xf022, (gen_utime >= utime_since) & (gen_utime < utime_until));

        (int block_header_id_kind, int block_header_id_workchain, int block_header_id_shard, int block_header_id_seqno, int block_header_id_root_hash, int block_header_id_file_hash) = parse_block_id(block_header_id_cs);
        slice message = begin_cell().store_uint(0x706e0bc5, 32).store_uint(root_hash, 256).store_uint(block_header_id_file_hash, 256).end_cell().begin_parse();

        verify_signatures(cur_validator_set, signatures, message);
        
        var correct_msg_body = begin_cell()
                        .store_uint(op::correct, 32)
                        .store_uint(query_id, 64)
                        .store_uint(root_hash, 256)
                        .end_cell();
        var msg = begin_cell()
                .store_uint(0x18, 6)
                .store_slice(sender_address)
                .store_coins(0)
                .store_uint(1, 1 + 4 + 4 + 64 + 32 + 1 + 1)
                .store_ref(correct_msg_body);
        send_raw_message(msg.end_cell(), 64);

        return ();
    }

    throw(error::unknown_opcode);
}
