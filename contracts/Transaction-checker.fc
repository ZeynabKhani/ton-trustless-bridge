#include "imports/stdlib.fc";

const op::check_transaction = 0x91d555f7;
const op::transaction_checked = 0x756adff1;
const op::check_block = 0x8eaa9d76;
const op::correct = 0xce02b807;
const op::reject = 0x7f3b8c1d;
const error::unknown_opcode = 0xffff;
const error::inconsistent_proof = 0xfff1;
const error::unauthorized = 0xfff2;
const error::transaction_not_found = 0xfff3;
const error::transaction_not_in_block = 0xfff4;


(slice, int) parse_exotic(cell x) asm "XCTOS";
(slice, slice) load_dicts(slice s) asm(-> 1 0) "LDDICTS";
int hash_at_level(cell x, int i) asm "CHASHIX";



(slice, cell) load_data() inline_ref {
    slice ds = get_data().begin_parse();
    return (
        ds~load_msg_addr(), ;;lite client address
        ds~load_dict() ;; check transaction requests
    );
}

() save_data(slice lite_client, cell check_transaction_requests) impure {
    set_data(
        begin_cell()
            .store_slice(lite_client)
            .store_dict(check_transaction_requests)
            .end_cell()
    );
}


;; Example function demonstrating dictionary (hashmap) usage
() example() inline {
    ;; Create an empty dictionary
    cell dict = new_dict();
    ;; ~strdump("new_dict");
    int c = 0;
    
    ;; Store values in dictionary (key length 256, value length 64)
    dict~udict_set(256, 123, begin_cell().store_uint(999, 64).end_cell().begin_parse());
    dict~udict_set(256, 456, begin_cell().store_uint(888, 64).end_cell().begin_parse());
    
    ;; Retrieve value from dictionary
    (slice value, int success) = dict.udict_get?(256, 123);
    if (success) {
        int retrieved_value = value~load_uint(64);
        ;; ~dump(retrieved_value);
        ;; retrieved_value will be 999
    }
    
    ;; Check if key exists
    ;; int key_exists = dict.udict_has?(256, 123);
    
    ;; Delete key-value pair
    dict~udict_delete?(256, 123);
    
    ;; Iterate through dictionary
    ;; (int key, slice value, int found) = dict.udict_get_min?(256);
    ;; while (found) {
    ;;     int val = value~load_uint(64);
    ;;     ;; Process value...
    ;;     ~dump(val);
    ;;     ;; Get next key-value pair
    ;;     (key, value, found) = dict.udict_get_next?(256, key);
    ;;     ~dump(found);
    ;; }
}

(int) compute_root_hash(cell block) impure inline {
    slice block_cs = block.begin_parse();
    slice block_header_cs = block_cs~load_ref().begin_parse();

    block_header_cs~load_int(32); ;; skip header kind
    slice block_header_id_cs = block_header_cs~load_ref().begin_parse(); ;; skip header id cs

    block_header_id_cs~load_int(32); ;; skip kind
    block_header_id_cs~load_int(32); ;; skip workchin
    block_header_id_cs~load_int(64); ;; skip shard
    block_header_id_cs~load_int(32); ;; skip seqno
    int block_header_id_root_hash = block_header_id_cs~load_uint(256);
    return block_header_id_root_hash;
}

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) {
        return ();
    }
    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);

    if (flags & 1) {        
        return ();
    }
    slice sender_address = cs~load_msg_addr();

    int op = in_msg_body~load_uint(32);
    (slice lite_client, cell check_transaction_requests) = load_data();

    if (op == op::check_transaction) {
        int query_id = in_msg_body~load_uint(64);
        cell transaction = in_msg_body~load_ref();
        cell proof = in_msg_body~load_ref(); ;; tx proof
        cell current_block = in_msg_body~load_ref(); 

        slice current_block_cs = current_block.begin_parse();
        cell block_data = current_block_cs~load_ref(); ;; block data
        int block_root_hash = compute_root_hash(block_data); ;; compute root hash

        cell block_signature = current_block_cs~load_dict(); ;; block proof

        ;; check proofs to confirm that a given transaction was committed in some masterchain block of the current epoch.
        ;; check root hash of block is equal to proof.refs[0].hashes[0];

        (slice proof_slice, int is_exotic) = parse_exotic(proof);
        throw_unless(0xf001, is_exotic == -1);
        cell first_proof_ref = proof_slice~load_ref();
        int proof_root_hash = hash_at_level(first_proof_ref, 0);

        proof_slice~load_uint(8); ;;skip cell type
        
        throw_unless(error::inconsistent_proof, proof_root_hash == proof_slice~load_uint(256));
        throw_unless(error::inconsistent_proof, proof_root_hash == block_root_hash);
        
        ;; check tx hash in proof

        slice transaction_cs = transaction.begin_parse();
        int tx_hash = transaction_cs~load_uint(256);

        slice first_proof_ref_cs = first_proof_ref.begin_parse();
        first_proof_ref_cs~load_ref(); ;; skip ref 0
        first_proof_ref_cs~load_ref(); ;; skip ref 1
        first_proof_ref_cs~load_ref(); ;; skip ref 2
        cell block_extra = first_proof_ref_cs~load_ref(); ;; block extra 
        slice block_extra_cs = block_extra.begin_parse();
        block_extra_cs~load_ref();
        block_extra_cs~load_ref();

        cell account_blocks = block_extra_cs~load_ref();
        slice account_blocks_cs = account_blocks.begin_parse();
        cell ref0 = account_blocks_cs~load_ref();
        slice ref0_cs = ref0.begin_parse();
        while (ref0_cs.slice_bits() < 100) {
            ref0 = ref0_cs~load_ref();
            try {
                ref0_cs = ref0.begin_parse();
            } catch (x, n) {
                ref0 = ref0_cs~load_ref();
                ref0_cs = ref0.begin_parse();
            }
        }
        int flag = 0;
        while (ref0_cs.slice_refs_empty?() != -1) {
            try {
                cell next_cell = ref0_cs~load_ref();
                (slice ref1, int is_exotic) = parse_exotic(next_cell);
                while (is_exotic == 0) {
                    if (ref1.slice_refs_empty?() != -1) {
                        next_cell = ref1~load_ref();
                        (ref1, is_exotic) = parse_exotic(next_cell);
                    } else {
                        is_exotic = -1;
                    }
                }
                ref1~skip_bits(16);
                if (ref1~load_uint(256) == tx_hash) {
                    flag = 1;
                }
            } catch (x, n) {
                ref0_cs~load_ref();
            }
        }
        throw_unless(error::transaction_not_in_block, flag == 1);
        check_transaction_requests~udict_set_ref(64, query_id, begin_cell().store_slice(sender_address).store_ref(transaction).end_cell()); ;; store sender address for this query id

        ;; query lite client to check block
        var check_block_msg_body = begin_cell()
                        .store_uint(op::check_block, 32)
                        .store_uint(query_id, 64)
                        .store_ref(block_data)
                        .store_dict(block_signature)
                        .end_cell();
        var msg = begin_cell()
                .store_uint(0x18, 6)
                .store_slice(lite_client)
                .store_coins(0)
                .store_uint(1, 1 + 4 + 4 + 64 + 32 + 1 + 1)
                .store_ref(check_block_msg_body);

        send_raw_message(msg.end_cell(), 64); 

        save_data(lite_client, check_transaction_requests);
        return ();
    }

    if (op == op::correct) {
        throw_unless(error::unauthorized, equal_slices_bits(sender_address, lite_client));
        int query_id = in_msg_body~load_uint(64); ;; query id
        (cell data, int success) = check_transaction_requests.udict_get_ref?(64, query_id);
        if (success) {
            slice data_cs = data.begin_parse();
            slice from_address = data_cs~load_msg_addr();
            cell transaction = data_cs~load_ref();
            check_transaction_requests~udict_delete?(64, query_id);
            
            var transaction_checked_msg_body = begin_cell()
                            .store_uint(op::transaction_checked, 32)
                            .store_ref(transaction)
                            .end_cell();
            var msg = begin_cell()
                    .store_uint(0x18, 6)
                    .store_slice(from_address)
                    .store_coins(0)
                    .store_uint(1, 1 + 4 + 4 + 64 + 32 + 1 + 1)
                    .store_ref(transaction_checked_msg_body);
            send_raw_message(msg.end_cell(), 64); 
        } else {
            throw(error::transaction_not_found);
        }

        save_data(lite_client, check_transaction_requests);
        return ();
    }

    if (op == op::reject) {
        throw_unless(error::unauthorized, equal_slices_bits(sender_address, lite_client));

        int query_id = in_msg_body~load_uint(64); ;; query id
        (cell data, int success) = check_transaction_requests.udict_get_ref?(64, query_id);

        if (success) {
            check_transaction_requests~udict_delete?(64, query_id);
        } 

        save_data(lite_client, check_transaction_requests);
        return ();
    }
    
    throw(error::unknown_opcode);
}

(slice) get_key(int key) method_id {
    (slice lite_client, cell check_transaction_requests) = load_data();
    (slice payload, int success) = check_transaction_requests.udict_get?(64, key);
    return payload;
}