#include "imports/stdlib.fc";

const op::check_transaction = 0x91d555f7;
const op::transaction_checked = 0x756adff1;
const op::check_block = 0x8eaa9d76;
const op::correct = 0xce02b807;
const op::reject = 0x7f3b8c1d;
const error::unknown_opcode = 0xffff;
const error::inconsistent_proof = 0xfff1;
const error::unauthorized = 0xfff2;
const error::transaction_not_found = 0xfff3;
const error::transaction_not_in_block = 0xfff4;
const error::not_exotic = 0xf001;


(slice, int) parse_exotic(cell x) asm "XCTOS";
int hash_at_level(cell x, int i) asm "CHASHIX"; 

(slice, cell, int) load_data() inline_ref {
    slice ds = get_data().begin_parse();
    return (
        ds~load_msg_addr(), ;;lite client address
        ds~load_dict(), ;; check transaction requests, store pending transactions that are sent to lite client
        ds~load_uint(256) ;; queries counter
    );
}

() save_data(slice lite_client, cell check_transaction_requests, int queries_cnt) impure {
    set_data(
        begin_cell()
            .store_slice(lite_client)
            .store_dict(check_transaction_requests)
            .store_uint(queries_cnt, 256)
            .end_cell()
    );
}

;; compute root hash for the block cell
(int) compute_root_hash(cell block) impure inline {
    slice block_cs = block.begin_parse();
    slice block_header_cs = block_cs~load_ref().begin_parse();

    block_header_cs~skip_bits(32); ;; skip header kind
    slice block_header_id_cs = block_header_cs~load_ref().begin_parse(); ;; skip header id cs

    block_header_id_cs~skip_bits(32); ;; skip kind
    block_header_id_cs~skip_bits(32); ;; skip workchin
    block_header_id_cs~skip_bits(64); ;; skip shard
    block_header_id_cs~skip_bits(32); ;; skip seqno
    int block_header_id_root_hash = block_header_id_cs~load_uint(256);
    return block_header_id_root_hash;
}

;; verify that tx hash exists in the account blocks' transactions list
(int) verify_tx_hash (int tx_hash, cell block_extra) impure inline {
    slice block_extra_cs = block_extra.begin_parse();
    block_extra_cs~load_ref(); ;; skip InMsgDescr
    block_extra_cs~load_ref(); ;; skip OutMsgDescr

    cell account_blocks = block_extra_cs~load_ref(); 
    slice account_blocks_cs = account_blocks.begin_parse();
    cell ref0 = account_blocks_cs~load_ref();
    slice ref0_cs = ref0.begin_parse(); ;; will contain the final account block

    int flag = 0;

    while (ref0_cs.slice_bits() < 256) {
        ref0 = ref0_cs~load_ref();
        try {
            ref0_cs = ref0.begin_parse();
        } catch (x, n) {
            ref0 = ref0_cs~load_ref();
            ref0_cs = ref0.begin_parse();
        }
    }

    ;; account block containing the transaction is in ref0_cs

    while (ref0_cs.slice_refs_empty?() != -1) {
        try {
            cell next_cell = ref0_cs~load_ref();
            (slice ref1, int is_exotic) = parse_exotic(next_cell);
            while (is_exotic == 0) {
                if (ref1.slice_refs_empty?() != -1) {
                    next_cell = ref1~load_ref();
                    (ref1, is_exotic) = parse_exotic(next_cell); ;; transaction is stored in an exotic cell
                } else {
                    is_exotic = -1;
                }
            }
            ref1~skip_bits(16); ;; skip extra bits to get the tx hash
            if (ref1~load_uint(256) == tx_hash) { ;; compare tx hash in block extra to expected tx hash of transaction
                flag = 1;
            }
        } catch (x, n) {
            ref0_cs~load_ref();
        }
    }
    return flag;
}

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) {
        return ();
    }
    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);

    if (flags & 1) {        
        return ();
    }

    slice sender_address = cs~load_msg_addr();

    int op = in_msg_body~load_uint(32);
    (slice lite_client, cell check_transaction_requests, int queries_cnt) = load_data();

    if (op == op::check_transaction) {
        int query_id = queries_cnt; ;; unique counter for query id
        cell transaction = in_msg_body~load_ref();
        cell proof = in_msg_body~load_ref();
        cell current_block = in_msg_body~load_ref(); 

        slice current_block_cs = current_block.begin_parse();
        cell block_data = current_block_cs~load_ref(); ;; block data

        ;; check proofs to confirm that a given transaction was committed in some masterchain block of the current epoch
        ;; check root hash of block is equal to proof.refs[0].hashes[0];

        int block_root_hash = compute_root_hash(block_data); ;; compute root hash
        (slice proof_slice, int is_exotic) = parse_exotic(proof);
        throw_unless(error::not_exotic, is_exotic == -1);
        cell first_proof_ref = proof_slice~load_ref();
        int proof_root_hash = hash_at_level(first_proof_ref, 0);

        proof_slice~skip_bits(8); ;;skip cell type
        
        throw_unless(error::inconsistent_proof, proof_root_hash == proof_slice~load_uint(256));
        throw_unless(error::inconsistent_proof, proof_root_hash == block_root_hash);
        
        ;; compute tx hash
        int tx_hash = hash_at_level(transaction, 0);

        ;; check existance of tx hash in proof
        ;; we should search for tx hash in block extra -> account blocks -> account block -> transactions

        ;; extracting block extra
        slice first_proof_ref_cs = first_proof_ref.begin_parse();
        first_proof_ref_cs~load_ref(); ;; skip ref 0
        first_proof_ref_cs~load_ref(); ;; skip ref 1
        first_proof_ref_cs~load_ref(); ;; skip ref 2
        cell block_extra = first_proof_ref_cs~load_ref(); ;; block extra 

        ;; verify that tx hash exists in block extra
        int flag = verify_tx_hash(tx_hash, block_extra);

        throw_unless(error::transaction_not_in_block, flag == 1);

        ;; store transaction in dict to answer correct or reject in future
        check_transaction_requests~udict_set_ref(
            64, 
            query_id, 
            begin_cell()
            .store_slice(sender_address)
            .store_ref(transaction)
            .end_cell()
        );

        cell block_signature = current_block_cs~load_dict(); ;; block proof

        ;; query lite client to check block
        var check_block_msg_body = begin_cell()
                        .store_uint(op::check_block, 32)
                        .store_uint(query_id, 64)
                        .store_ref(block_data)
                        .store_dict(block_signature)
                        .end_cell();
        var msg = begin_cell()
                .store_uint(0x18, 6)
                .store_slice(lite_client)
                .store_coins(0)
                .store_uint(1, 1 + 4 + 4 + 64 + 32 + 1 + 1)
                .store_ref(check_block_msg_body);

        send_raw_message(msg.end_cell(), 64); 

        save_data(lite_client, check_transaction_requests, queries_cnt + 1);
        return ();
    }

    ;; will be called by lite client if check block is correct
    if (op == op::correct) {
        throw_unless(error::unauthorized, equal_slices_bits(sender_address, lite_client)); ;; only lite client can call this method
        int query_id = in_msg_body~load_uint(64); 

        ;; query data related to this transaction
        (cell data, int success) = check_transaction_requests.udict_get_ref?(64, query_id);

        if (success) {
            slice data_cs = data.begin_parse();
            slice from_address = data_cs~load_msg_addr();
            cell transaction = data_cs~load_ref();

            ;; delete transaction from dict to avoid memory overhead
            check_transaction_requests~udict_delete?(64, query_id);
            
            var transaction_checked_msg_body = begin_cell()
                            .store_uint(op::transaction_checked, 32)
                            .store_ref(transaction)
                            .end_cell();
            var msg = begin_cell()
                    .store_uint(0x18, 6)
                    .store_slice(from_address)
                    .store_coins(0)
                    .store_uint(1, 1 + 4 + 4 + 64 + 32 + 1 + 1)
                    .store_ref(transaction_checked_msg_body);
            send_raw_message(msg.end_cell(), 64); 
        } else {
            throw(error::transaction_not_found); ;; should never happen
        }

        save_data(lite_client, check_transaction_requests, queries_cnt);
        return ();
    }

    ;; will be called by lite client if check block is rejected
    if (op == op::reject) {
        throw_unless(error::unauthorized, equal_slices_bits(sender_address, lite_client)); ;; only lite client can call this method

        int query_id = in_msg_body~load_uint(64); 

        ;; delete transaction from dict to avoid memory overhead
        check_transaction_requests~udict_delete?(64, query_id);
        
        save_data(lite_client, check_transaction_requests, queries_cnt);
        return ();
    }
    
    throw(error::unknown_opcode);
}

(slice) get_key(int key) method_id {
    (slice lite_client, cell check_transaction_requests, int queries_cnt) = load_data();
    (slice payload, int success) = check_transaction_requests.udict_get?(64, key);
    return payload;
}